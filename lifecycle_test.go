// WARNING: This file contains tests generated by AI.

package goscade

import (
	"context"
	"errors"
	"reflect"
	"strings"
	"testing"
	"time"

	"golang.org/x/sync/errgroup"
)

// Test: mockComponentCyclic is used to create a cyclic dependency
// Implements Component
// readinessProbe is called immediately

type mockComponentCyclic struct {
	dep Component
}

func (m *mockComponentCyclic) Run(ctx context.Context, readinessProbe func(error)) error {
	readinessProbe(nil)
	<-ctx.Done()
	return nil
}

// Test: CyclicStruct is used to create a cyclic dependency via the Dep field
// Implements Component

type CyclicStruct struct {
	Dep Component
}

func (c *CyclicStruct) Run(ctx context.Context, readinessProbe func(error)) error {
	readinessProbe(nil)
	<-ctx.Done()
	return nil
}

// Test: Circular dependency detection
func TestLifecycle_RunAllComponents_CircularDependency_Panic(t *testing.T) {
	lc := NewLifecycle(&mockLogger{})

	compA := &mockComponentCyclic{}
	compB := &mockComponentCyclic{dep: compA}
	compA.dep = compB // create cycle

	lc.Register(compA)
	lc.Register(compB)

	// manually add dependencies to ptrToComp so findParentComponents can see them
	lcImpl := lc.(*lifecycle)
	lcImpl.ptrToComp[reflect.ValueOf(compA).Pointer()] = compA
	lcImpl.ptrToComp[reflect.ValueOf(compB).Pointer()] = compB

	// wrap components in structs with dependencies
	cyclicA := &CyclicStruct{Dep: compB}
	cyclicB := &CyclicStruct{Dep: compA}

	lc.Register(cyclicA)
	lc.Register(cyclicB)
	lcImpl.ptrToComp[reflect.ValueOf(cyclicA).Pointer()] = cyclicA
	lcImpl.ptrToComp[reflect.ValueOf(cyclicB).Pointer()] = cyclicB

	g, ctx := errgroup.WithContext(context.Background())

	defer func() {
		rec := recover()
		if rec == nil {
			t.Fatal("expected panic due to circular dependency, but did not panic")
		}
		panicMsg, ok := rec.(string)
		if !ok || !strings.Contains(panicMsg, "circular dependency detected") {
			t.Fatalf("unexpected panic message: %v", rec)
		}
	}()

	lc.RunAllComponents(g, ctx)
}

// Test: Successful pointer registration
func TestLifecycle_Register_Pointer(t *testing.T) {
	lc := NewLifecycle(&mockLogger{})
	comp := &mockComponentCyclic{}
	defer func() {
		if r := recover(); r != nil {
			t.Fatalf("unexpected panic: %v", r)
		}
	}()
	lc.Register(comp)
}

// Test: Dependencies with a single component without dependencies
func TestLifecycle_Dependencies_Simple(t *testing.T) {
	lc := NewLifecycle(&mockLogger{})
	comp := &mockComponentCyclic{}
	lc.Register(comp)
	deps := lc.Dependencies()
	if len(deps) != 1 {
		t.Errorf("expected 1 component, got %d", len(deps))
	}
	if len(deps[comp]) != 0 {
		t.Errorf("expected 0 dependencies, got %d", len(deps[comp]))
	}
}

// Test: Dependencies with dependencies
func TestLifecycle_Dependencies_WithDeps(t *testing.T) {
	lc := NewLifecycle(&mockLogger{})
	compA := &mockComponentCyclic{}
	compB := &mockComponentCyclic{dep: compA}
	lc.Register(compA)
	lc.Register(compB)
	lcImpl := lc.(*lifecycle)
	lcImpl.ptrToComp[reflect.ValueOf(compA).Pointer()] = compA
	lcImpl.ptrToComp[reflect.ValueOf(compB).Pointer()] = compB
	deps := lc.Dependencies()
	if len(deps) != 2 {
		t.Errorf("expected 2 components, got %d", len(deps))
	}
	if len(deps[compB]) != 1 {
		t.Errorf("expected 1 dependency for compB, got %d", len(deps[compB]))
	}
}

// Test: buildCompToParents and buildCompToChildren
func TestLifecycle_BuildCompToParents_And_Children(t *testing.T) {
	lc := NewLifecycle(&mockLogger{})
	compA := &mockComponentCyclic{}
	compB := &mockComponentCyclic{dep: compA}
	lc.Register(compA)
	lc.Register(compB)
	lcImpl := lc.(*lifecycle)
	lcImpl.ptrToComp[reflect.ValueOf(compA).Pointer()] = compA
	lcImpl.ptrToComp[reflect.ValueOf(compB).Pointer()] = compB
	parents := lcImpl.buildCompToParents()
	children := lcImpl.buildCompToChildren(parents)
	if len(parents) == 0 || len(children) == 0 {
		t.Error("parents or children map is empty")
	}
}

// Test: Run with no components
func TestLifecycle_NoComponents(t *testing.T) {
	lc := NewLifecycle(&mockLogger{})
	g, ctx := errgroup.WithContext(context.Background())
	defer func() {
		if r := recover(); r != nil {
			t.Fatalf("unexpected panic: %v", r)
		}
	}()
	lc.RunAllComponents(g, ctx)
}

// Test: Correct status transitions
func TestLifecycle_Status_Transitions(t *testing.T) {
	lc := NewLifecycle(&mockLogger{})
	lcImpl := lc.(*lifecycle)
	ctx := context.Background()
	if lc.Status() != LifecycleStatusIdle {
		t.Errorf("expected status idle, got %s", lc.Status())
	}
	lcImpl.setStatus(ctx, LifecycleStatusRunning)
	if lc.Status() != LifecycleStatusRunning {
		t.Errorf("expected status running, got %s", lc.Status())
	}
	lcImpl.setStatus(ctx, LifecycleStatusReady)
	if lc.Status() != LifecycleStatusReady {
		t.Errorf("expected status ready, got %s", lc.Status())
	}
	lcImpl.setStatus(ctx, LifecycleStatusStopping)
	if lc.Status() != LifecycleStatusStopping {
		t.Errorf("expected status stopping, got %s", lc.Status())
	}
	lcImpl.setStatus(ctx, LifecycleStatusStopped)
	if lc.Status() != LifecycleStatusStopped {
		t.Errorf("expected status stopped, got %s", lc.Status())
	}
}

// Test: Graceful shutdown
func TestLifecycle_RunAllComponents_GracefulShutdown(t *testing.T) {
	lc := NewLifecycle(&mockLogger{})
	comp := &mockComponentCyclic{}
	lc.Register(comp)
	lcImpl := lc.(*lifecycle)
	lcImpl.ptrToComp[reflect.ValueOf(comp).Pointer()] = comp
	cancelCtx, cancel := context.WithCancel(context.Background())
	g, ctx := errgroup.WithContext(cancelCtx)

	// Start components
	go func() {
		lc.RunAllComponents(g, ctx)
	}()

	// Wait until status becomes Ready
	for lc.Status() != LifecycleStatusReady {
		time.Sleep(10 * time.Millisecond)
	}

	// Cancel context
	cancel()

	// Wait until status becomes Stopped
	for lc.Status() != LifecycleStatusStopped {
		time.Sleep(10 * time.Millisecond)
	}
}

// Test: Component error handling
type errorComponent struct{}

func (e *errorComponent) Run(ctx context.Context, readinessProbe func(error)) error {
	readinessProbe(nil)
	return errors.New("component error")
}

// Test: Component error causes lifecycle to stop
func TestLifecycle_RunAllComponents_ComponentError(t *testing.T) {
	lc := NewLifecycle(&mockLogger{})
	comp := &errorComponent{}
	lc.Register(comp)
	lcImpl := lc.(*lifecycle)
	lcImpl.ptrToComp[reflect.ValueOf(comp).Pointer()] = comp
	g, ctx := errgroup.WithContext(context.Background())

	// Start components
	go func() {
		lc.RunAllComponents(g, ctx)
	}()

	// Wait until status becomes Stopped
	for lc.Status() != LifecycleStatusStopped {
		time.Sleep(10 * time.Millisecond)
	}
}
